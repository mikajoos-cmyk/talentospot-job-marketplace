diff --git a/src/components/candidate/JobFilters.tsx b/src/components/candidate/JobFilters.tsx
index 9315d3f..8e2854c 100644
--- a/src/components/candidate/JobFilters.tsx
+++ b/src/components/candidate/JobFilters.tsx
@@ -491,7 +491,7 @@ const JobFilters: React.FC<JobFiltersProps> = ({ filters, onFiltersChange, onMat
                                         <SelectValue placeholder="Lvl" />
                                     </SelectTrigger>
                                     <SelectContent>
-                                        {getLanguageLevelOptions(true).map(opt => (
+                                        {getLanguageLevelOptions().map(opt => (
                                             <SelectItem key={opt.value} value={opt.value}>{opt.label}</SelectItem>
                                         ))}
                                     </SelectContent>
diff --git a/src/components/employer/CandidateCard.tsx b/src/components/employer/CandidateCard.tsx
index e789804..e2ed20e 100644
--- a/src/components/employer/CandidateCard.tsx
+++ b/src/components/employer/CandidateCard.tsx
@@ -200,9 +200,8 @@ const CandidateCard: React.FC<CandidateCardProps> = ({ candidate, accessStatus,
   const sector = candidate.sector || candidate.industry || 'General';
   const careerLevel = candidate.career_level || candidate.careerLevel || 'Not specified';

-  // Robust availability parsing
-  const rawAvailability = candidate.available_from || candidate.availableFrom || candidate.conditions?.startDate;
-  const availability = rawAvailability ? new Date(rawAvailability).toLocaleDateString() : 'Immediate';
+  // Notice period parsing
+  const noticePeriod = candidate.notice_period || candidate.noticePeriod || 'Immediate';

   const skills = candidate.candidate_skills || candidate.skills || [];
   const languages = candidate.candidate_languages || candidate.languages || [];
@@ -307,13 +306,13 @@ const CandidateCard: React.FC<CandidateCardProps> = ({ candidate, accessStatus,
                   <p className="text-sm font-semibold">
                     {candidate.currency || 'EUR'} {minSalary.toLocaleString()} - {maxSalary.toLocaleString()}
                   </p>
-                  {entryBonus && <p className="text-xs font-bold text-[#FFB800]">Entry Bonus: €{entryBonus.toLocaleString()}</p>}
+                  {entryBonus && <p className="text-sm font-bold text-[#FFB800]">Entry Bonus: €{entryBonus.toLocaleString()}</p>}
                 </div>
               </div>

               <div className="flex items-center gap-2 text-muted-foreground pt-2">
                 <Calendar className="w-3.5 h-3.5" />
-                <span className="text-[11px] font-bold uppercase tracking-wide">Available: {availability}</span>
+                <span className="text-[11px] font-bold uppercase tracking-wide">Notice Period: {noticePeriod}</span>
               </div>
             </div>

diff --git a/src/components/employer/CandidateFilters.tsx b/src/components/employer/CandidateFilters.tsx
index 954c6be..5bf1847 100644
--- a/src/components/employer/CandidateFilters.tsx
+++ b/src/components/employer/CandidateFilters.tsx
@@ -570,7 +570,7 @@ const CandidateFilters: React.FC<CandidateFiltersProps> = ({ filters, onFiltersC
                     <SelectValue placeholder="Lvl" />
                   </SelectTrigger>
                   <SelectContent>
-                    {getLanguageLevelOptions(true).map(opt => (
+                    {getLanguageLevelOptions().map(opt => (
                       <SelectItem key={opt.value} value={opt.value}>{opt.label}</SelectItem>
                     ))}
                   </SelectContent>
diff --git a/src/components/landing/MainHeroFilter.tsx b/src/components/landing/MainHeroFilter.tsx
index 4738a00..30d212d 100644
--- a/src/components/landing/MainHeroFilter.tsx
+++ b/src/components/landing/MainHeroFilter.tsx
@@ -716,7 +716,7 @@ const MainHeroFilter = () => {
                                                     <Select value={languageLevel} onValueChange={setLanguageLevel}>
                                                         <SelectTrigger className="h-10 w-24"><SelectValue /></SelectTrigger>
                                                         <SelectContent>
-                                                            {getLanguageLevelOptions(true).map(o => <SelectItem key={o.value} value={o.value}>{o.label}</SelectItem>)}
+                                                            {getLanguageLevelOptions().map(o => <SelectItem key={o.value} value={o.value}>{o.label}</SelectItem>)}
                                                         </SelectContent>
                                                     </Select>
                                                     <Button size="icon" variant="secondary" onClick={handleAddLanguage} className="h-10 w-10 shrink-0"><Plus className="w-4 h-4" /></Button>
diff --git a/src/pages/CandidateSearch.tsx b/src/pages/CandidateSearch.tsx
index 46b081f..b7f76fa 100644
--- a/src/pages/CandidateSearch.tsx
+++ b/src/pages/CandidateSearch.tsx
@@ -8,7 +8,7 @@ import { useUser } from '@/contexts/UserContext';
 import { CandidateFilters as CandidateFiltersType } from '@/types/candidate';
 import { candidateService } from '@/services/candidate.service';
 import { jobsService, Job } from '@/services/jobs.service';
-import { Loader2, Briefcase } from 'lucide-react';
+import { Loader2, Briefcase, ArrowUpDown, ArrowUp, ArrowDown } from 'lucide-react';
 import { calculateCandidateMatchScore } from '@/utils/match-utils';
 import { Button } from '@/components/ui/button';
 import { getCoordinates } from '@/utils/geocoding';
@@ -17,8 +17,11 @@ import {
   DropdownMenuContent,
   DropdownMenuItem,
   DropdownMenuTrigger,
+  DropdownMenuSeparator,
 } from '@/components/ui/dropdown-menu';

+type SortOption = 'newest' | 'random' | 'salary' | 'distance' | 'match';
+
 const CandidateSearch: React.FC = () => {
   const { user } = useUser();
   const [loading, setLoading] = useState(true);
@@ -29,6 +32,8 @@ const CandidateSearch: React.FC = () => {
   const [loadingJobs, setLoadingJobs] = useState(false);
   const [searchParams] = useSearchParams();
   const [mapCenter, setMapCenter] = useState<[number, number]>([51.1657, 10.4515]);
+  const [sortBy, setSortBy] = useState<SortOption>('newest');
+  const [sortAscending, setSortAscending] = useState<boolean>(false);
   const [filters, setFilters] = useState<CandidateFiltersType>(() => {
     // 1. First, check if there are URL parameters (these should override everything)

@@ -224,15 +229,25 @@ const CandidateSearch: React.FC = () => {
         setLoading(true);
         const searchFilters: any = {};

+        // Apply filters ONLY when NOT in partial match mode
         if (!filters.enablePartialMatch) {
+          // Location filters
+          if (filters.location.continent) {
+            searchFilters.continent = filters.location.continent;
+          }
+
+          if (filters.location.country) {
+            searchFilters.country = filters.location.country;
+          }
+
+          if (filters.location.cities && filters.location.cities.length > 0) {
+            searchFilters.city = filters.location.cities[0];
+          }
+
           if (filters.salary[0] > 20000) searchFilters.min_salary = filters.salary[0];
           if (filters.salary[1] < 200000) searchFilters.max_salary = filters.salary[1];
           if (filters.bonus[0] > 0) searchFilters.min_bonus = filters.bonus[0];
           if (filters.bonus[1] < 100000) searchFilters.max_bonus = filters.bonus[1];
-          if (filters.bonus[0] > 0) searchFilters.min_bonus = filters.bonus[0];
-          if (filters.bonus[1] < 100000) searchFilters.max_bonus = filters.bonus[1];
-
-          // Radius logic refactored: Passed separately below.

           if (filters.jobTitle) {
             searchFilters.job_title = filters.jobTitle;
@@ -309,18 +324,6 @@ const CandidateSearch: React.FC = () => {
             searchFilters.qualifications = filters.qualifications;
           }

-          if (filters.location.continent) {
-            searchFilters.continent = filters.location.continent;
-          }
-
-          if (filters.location.country) {
-            searchFilters.country = filters.location.country;
-          }
-
-          if (filters.location.cities && filters.location.cities.length > 0) {
-            searchFilters.city = filters.location.cities[0];
-          }
-
           if (filters.gender && filters.gender.length > 0) {
             searchFilters.gender = filters.gender;
           }
@@ -330,8 +333,9 @@ const CandidateSearch: React.FC = () => {
           }
         }

-        // Pass radius separately. Service handles deciding if radius search applies (needs city).
-        const data = await candidateService.searchCandidates(searchFilters, radiusValue);
+        // Pass radius only when NOT in partial match mode
+        const searchRadiusValue = filters.enablePartialMatch ? undefined : radiusValue;
+        const data = await candidateService.searchCandidates(searchFilters, searchRadiusValue);
         let results = data || [];

         if (filters.enablePartialMatch) {
@@ -364,6 +368,96 @@ const CandidateSearch: React.FC = () => {
     loadCandidates();
   }, [filters, radiusValue]);

+  // Sort candidates based on selected option
+  const sortedCandidates = React.useMemo(() => {
+    let sorted = [...candidates];
+    const direction = sortAscending ? 1 : -1;
+
+    switch (sortBy) {
+      case 'newest':
+        // Sort by created_at or id
+        sorted.sort((a, b) => {
+          const dateA = a.created_at ? new Date(a.created_at).getTime() : 0;
+          const dateB = b.created_at ? new Date(b.created_at).getTime() : 0;
+          return direction * (dateB - dateA || b.id - a.id);
+        });
+        break;
+
+      case 'random':
+        // Shuffle array (ignore direction for random)
+        for (let i = sorted.length - 1; i > 0; i--) {
+          const j = Math.floor(Math.random() * (i + 1));
+          [sorted[i], sorted[j]] = [sorted[j], sorted[i]];
+        }
+        break;
+
+      case 'salary':
+        // Sort by salary expectation
+        sorted.sort((a, b) => {
+          const salaryA = a.salary_expectation_max || a.salary?.max || 0;
+          const salaryB = b.salary_expectation_max || b.salary?.max || 0;
+          return direction * (salaryB - salaryA);
+        });
+        break;
+
+      case 'distance':
+        // Sort by distance to work location
+        sorted.sort((a, b) => {
+          // Calculate distance from latitude/longitude if available
+          const distA = a.distance || (a.latitude && a.longitude && filters.location.cities?.[0] ?
+            calculateDistance(mapCenter[0], mapCenter[1], a.latitude, a.longitude) : Infinity);
+          const distB = b.distance || (b.latitude && b.longitude && filters.location.cities?.[0] ?
+            calculateDistance(mapCenter[0], mapCenter[1], b.latitude, b.longitude) : Infinity);
+          return direction * (distA - distB);
+        });
+        break;
+
+      case 'match':
+        // Sort by match score (only when partial match is enabled)
+        sorted.sort((a, b) => {
+          const scoreA = a.matchScore || 0;
+          const scoreB = b.matchScore || 0;
+          return direction * (scoreB - scoreA);
+        });
+        break;
+
+      default:
+        break;
+    }
+
+    return sorted;
+  }, [candidates, sortBy, sortAscending, mapCenter, filters.location.cities]);
+
+  // Helper function to calculate distance between two coordinates (Haversine formula)
+  const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {
+    const R = 6371; // Radius of the Earth in km
+    const dLat = (lat2 - lat1) * Math.PI / 180;
+    const dLon = (lon2 - lon1) * Math.PI / 180;
+    const a =
+      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
+      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
+      Math.sin(dLon / 2) * Math.sin(dLon / 2);
+    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
+    return R * c;
+  };
+
+  const getSortLabel = (option: SortOption): string => {
+    switch (option) {
+      case 'newest': return 'Neueste';
+      case 'random': return 'Zufällig';
+      case 'salary': return 'Gehaltshöhe';
+      case 'distance': return 'Nächste zur Work Location';
+      case 'match': return 'Match %';
+      default: return 'Sortieren';
+    }
+  };
+
+  const toggleSortDirection = () => {
+    if (sortBy !== 'random') {
+      setSortAscending(!sortAscending);
+    }
+  };
+
   return (
     <>
       <AppLayout isPublic={user.role === 'guest'}>
@@ -449,10 +543,57 @@ const CandidateSearch: React.FC = () => {
                 </div>
               ) : (
                 <>
-                  <div className="mb-4">
+                  <div className="mb-4 flex items-center justify-between">
                     <p className="text-body text-foreground">
                       <span className="font-medium">{candidates.length}</span> candidates found
                     </p>
+
+                    {/* Sort Controls */}
+                    <div className="flex items-center gap-2">
+                      {/* Sort Direction Toggle (only show if not random) */}
+                      {sortBy !== 'random' && (
+                        <Button
+                          variant="outline"
+                          size="sm"
+                          onClick={toggleSortDirection}
+                          className="px-2"
+                        >
+                          {sortAscending ? <ArrowUp className="w-4 h-4" /> : <ArrowDown className="w-4 h-4" />}
+                        </Button>
+                      )}
+
+                      {/* Sort Dropdown */}
+                      <DropdownMenu>
+                        <DropdownMenuTrigger asChild>
+                          <Button variant="outline" size="sm">
+                            <ArrowUpDown className="w-4 h-4 mr-2" />
+                            {getSortLabel(sortBy)}
+                          </Button>
+                        </DropdownMenuTrigger>
+                        <DropdownMenuContent align="end">
+                          <DropdownMenuItem onClick={() => setSortBy('newest')}>
+                            Neueste
+                          </DropdownMenuItem>
+                          <DropdownMenuItem onClick={() => setSortBy('random')}>
+                            Zufällig
+                          </DropdownMenuItem>
+                          <DropdownMenuItem onClick={() => setSortBy('salary')}>
+                            Gehaltshöhe
+                          </DropdownMenuItem>
+                          <DropdownMenuItem onClick={() => setSortBy('distance')}>
+                            Nächste zur Work Location
+                          </DropdownMenuItem>
+                          {filters.enablePartialMatch && (
+                            <>
+                              <DropdownMenuSeparator />
+                              <DropdownMenuItem onClick={() => setSortBy('match')}>
+                                Match %
+                              </DropdownMenuItem>
+                            </>
+                          )}
+                        </DropdownMenuContent>
+                      </DropdownMenu>
+                    </div>
                   </div>

                   {candidates.length === 0 ? (
@@ -463,7 +604,7 @@ const CandidateSearch: React.FC = () => {
                     </div>
                   ) : (
                     <div className="grid grid-cols-1 gap-6">
-                      {candidates.map((candidate) => (
+                      {sortedCandidates.map((candidate) => (
                         <CandidateCard
                           key={candidate.id}
                           candidate={candidate}
diff --git a/src/services/candidate.service.ts b/src/services/candidate.service.ts
index 335f323..9b068fb 100644
--- a/src/services/candidate.service.ts
+++ b/src/services/candidate.service.ts
@@ -783,25 +783,10 @@ export const candidateService = {
   async searchCandidates(filters: any = {}, searchRadius?: number) {
     console.log('Searching candidates with filters:', filters);

-    // 1. IDs für Preferred Locations sammeln (falls Stadt gefiltert wird)
-    let preferredLocationCandidateIds: string[] = [];
-
     // Explicitly use the passed arg as the geographic radius
     const radius = searchRadius;

-    if (filters.city) {
-      // Suche in den verknüpften Tabellen nach der Stadt
-      const { data: prefData } = await supabase
-        .from('candidate_preferred_locations')
-        .select('candidate_id, cities!inner(name)')
-        .ilike('cities.name', `%${filters.city.trim()}%`);
-
-      if (prefData) {
-        preferredLocationCandidateIds = prefData.map((d: any) => d.candidate_id);
-      }
-    }
-
-    // 2. RADIUS SEARCH (Refactored)
+    // RADIUS SEARCH - Only based on candidate residence location
     let radiusCandidateIds: string[] | null = null;
     if (filters.city && radius) {
       console.log(`Performing Radius Search for ${filters.city} within ${radius}km`);
@@ -811,7 +796,7 @@ export const candidateService = {
       const searchLat = cityData?.latitude;
       const searchLon = cityData?.longitude;

-      // Step C: Execute RPC if we have coords
+      // Execute RPC if we have coords
       if (searchLat != null && searchLon != null) {
         const { data: radiusData, error: radiusError } = await supabase.rpc('search_candidates_radius', {
           search_lat: searchLat,
@@ -850,13 +835,11 @@ export const candidateService = {
       sector,
       career_level,
       employment_status,
+      currency,
+      created_at,
+      latitude,
+      longitude,
       profiles!inner(full_name, avatar_url, email, is_visible),
-      candidate_preferred_locations(
-        id,
-        cities(name),
-        countries(name),
-        continents(name)
-      ),
       candidate_skills${filters.skills?.length ? '!inner' : ''}(
         id,
         proficiency_percentage,
@@ -888,39 +871,20 @@ export const candidateService = {

     if (filters.city) {
       if (radiusCandidateIds !== null) {
-        // RADIUS SEARCH ACTIVE:
-        // Filter by the IDs returned from the RPC.
-        // NOTE: We do NOT add a strict city/country filter here because the RPC
-        // already checked "Residence OR Preferred Location" within the radius.
+        // RADIUS SEARCH ACTIVE: Filter by the IDs returned from the RPC (residence location only)
         if (radiusCandidateIds.length > 0) {
           query = query.in('id', radiusCandidateIds);
         } else {
           // Radius search returned no results -> force empty result
           query = query.eq('id', '00000000-0000-0000-0000-000000000000');
         }
-      } else if (preferredLocationCandidateIds.length > 0) {
-        // Fallback: No Radius or City coords not found -> Normal Text Search including preferred locations
-        // We match if city matches residence OR if candidate is in preferredLocationCandidateIds
-        const idsString = `(${preferredLocationCandidateIds.join(',')})`;
-        query = query.or(`city.ilike.%${filters.city.trim()}%,id.in.${idsString}`);
       } else {
-        // No preferred locations found for this city string -> Filter only by residence city
+        // Fallback: No Radius or City coords not found -> Normal Text Search by residence city only
         query = query.ilike('city', `%${filters.city.trim()}%`);
       }
     } else if (filters.country) {
-      // If ONLY country is selected (no city), we also want to include preferred locations in that country
-      const { data: countryPrefData } = await supabase
-        .from('candidate_preferred_locations')
-        .select('candidate_id, countries!inner(name)')
-        .ilike('countries.name', filters.country.trim());
-
-      if (countryPrefData && countryPrefData.length > 0) {
-        const countryPrefIds = countryPrefData.map((d: any) => d.candidate_id);
-        const countryIdsString = `(${countryPrefIds.join(',')})`;
-        query = query.or(`country.eq.${filters.country.trim()},id.in.${countryIdsString}`);
-      } else {
-        query = query.eq('country', filters.country);
-      }
+      // If ONLY country is selected (no city), filter by residence country only
+      query = query.eq('country', filters.country);
     }

     if (filters.career_level) {
@@ -1065,7 +1029,14 @@ export const candidateService = {
     }

     console.log(`Search returned ${data?.length || 0} candidates`);
-    return data?.map((item: any) => this.mapDbToProfile(item)) || [];
+    // Return raw data including notice_period instead of mapping through mapDbToProfile
+    // which might lose some fields needed for search results
+    return data?.map((item: any) => ({
+      ...item,
+      notice_period: item.notice_period,
+      currency: item.currency || 'EUR',
+      created_at: item.created_at
+    })) || [];
   },

   async getFeaturedTalent(limit: number = 6) {
diff --git a/src/types/candidate.ts b/src/types/candidate.ts
index e4a9344..d28dc3f 100644
--- a/src/types/candidate.ts
+++ b/src/types/candidate.ts
@@ -123,6 +123,5 @@ export interface CandidateFilters {
   homeOfficePreference?: ('yes' | 'no' | 'hybrid')[];
   vacationDays?: number[];
   noticePeriod?: string[];
-  preferredWorkLocations?: Array<{ continent: string; country: string; city: string; radius: number }>;
   customTags?: string[];
 }
diff --git a/src/utils/locationUtils.ts b/src/utils/locationUtils.ts
index 3a6a6b7..f891c74 100644
--- a/src/utils/locationUtils.ts
+++ b/src/utils/locationUtils.ts
@@ -2,14 +2,39 @@ import { locationData } from '../data/locationData';

 /**
  * Finds the continent for a given country name based on the locationData structure.
+ * - Case-insensitive match
+ * - Handles common aliases for some countries
  * @param countryName The name of the country.
- * @returns The name of the continent, or 'Europe' as a fallback.
+ * @returns The name of the continent, or 'Europe' as a safe fallback.
  */
 export const findContinent = (countryName: string): string => {
     if (!countryName) return 'Europe';

+    const raw = countryName.trim();
+    const lower = raw.toLowerCase();
+
+    // Common alias normalization
+    const aliasMap: Record<string, string> = {
+        'usa': 'United States',
+        'us': 'United States',
+        'united states of america': 'United States',
+        'u.k.': 'United Kingdom',
+        'uk': 'United Kingdom',
+        'great britain': 'United Kingdom',
+        'uae': 'United Arab Emirates',
+        'u.a.e.': 'United Arab Emirates',
+        'republic of korea': 'South Korea',
+        'korea, republic of': 'South Korea',
+        'south korea': 'South Korea',
+        'czechia': 'Czech Republic'
+    };
+
+    const normalized = aliasMap[lower] || raw;
+
     for (const [continent, countries] of Object.entries(locationData)) {
-        if (Object.keys(countries as object).includes(countryName)) {
+        const countryKeys = Object.keys(countries as object);
+        // Try exact (case-insensitive)
+        if (countryKeys.some(k => k.toLowerCase() === normalized.toLowerCase())) {
             return continent;
         }
     }
diff --git a/src/utils/match-utils.ts b/src/utils/match-utils.ts
index aa9287c..e2171db 100644
--- a/src/utils/match-utils.ts
+++ b/src/utils/match-utils.ts
@@ -521,19 +521,8 @@ export const calculateCandidateMatchScore = (candidate: any, filters: any): numb
         });
     }

-    // Preferred Work Locations
-    if (filters.preferredWorkLocations && filters.preferredWorkLocations.length > 0) {
-        total += 1;
-        const candidateLocations = candidate.preferred_work_locations || candidate.preferredLocations || [];
-        // Match if ANY filter location overlaps with ANY candidate location
-        const hasMatch = filters.preferredWorkLocations.some((filterLoc: any) =>
-            candidateLocations.some((candLoc: any) => {
-                // Simple city match for now (radius calculation would require geocoding)
-                return candLoc.city?.toLowerCase() === filterLoc.city?.toLowerCase();
-            })
-        );
-        if (hasMatch) matched += 1;
-    }
+    // Location matching is handled by radius search in the database query
+    // We don't need to match preferred work locations in the score calculation

     // Custom Tags - Each tag must match individually
     if (filters.customTags && filters.customTags.length > 0) {